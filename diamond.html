<html>
	<head>
		<title>Diamond Go</title>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script type="text/javascript">
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);
			camera.position.z = 3;

			function Node(rank,x,y) {
				this.rank = rank;
				this.x = x;
				this.y = y;
				this.links = [];
				this.key = [rank,x,y];
			}

			linesGeo = new THREE.Geometry();

			Node.prototype = {
				constructor : Node,
				makeMesh : function(ranks) {
					var mesh = new THREE.Mesh(nodeGeo,nodeMat);
					mesh.position.y = (ranks/2 - this.rank) * rankHeight;
					mesh.position.x = this.x * rankDiag;
					mesh.position.z = this.y * rankDiag;
					this.mesh = mesh;
					mesh.node = this;
					scene.add(mesh);
				},
				link : function(nodeB) {
					if (nodeB) {
						this.links.push(nodeB);
						nodeB.links.push(this);
						linesGeo.vertices.push(this.mesh.position);
						linesGeo.vertices.push(nodeB.mesh.position);
						console.log(this.mesh.position,"-->",nodeB.mesh.position);
					}
				},
				resolveDownLinks : function(nodes) {
					this.link(nodes[[this.rank+1, this.x-1, this.y]]);
					this.link(nodes[[this.rank+1, this.x+1, this.y]]);
					this.link(nodes[[this.rank+1, this.x, this.y -1]]);
					this.link(nodes[[this.rank+1, this.x, this.y +1]]);
				}

			}
			var rankHeight = 0.1;
			var rankDiag = rankHeight * Math.sqrt(2);
			var nodeMat = new THREE.MeshBasicMaterial({color:0x00ff00});
			var nodeSelMat = new THREE.MeshBasicMaterial({color:0x0000ff});
			var nodeGeo = new THREE.BoxGeometry(0.04,0.04,0.04);
			var linkMat = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 1, linewidth: 2.5 } );
			// THREE.ImageUtils.crossOrigin ='file:///home/phooky/Repos/phooky/diamond-go/';
			// console.log(THREE.ImageUtils.crossOrigin);
			// var nodeTex = THREE.ImageUtils.loadTexture( "./node-tex.png" );
   //          var nodeSpriteMat = new THREE.SpriteMaterial( { map: nodeTex, color: 0xffffff, fog: true } );
   //          var sprite = new THREE.Sprite( nodeSpriteMat );
   //          scene.add( sprite );

			function buildNodes(ranks) {
				var nodes = {};
				var nodelist = [];
				var total = 0;
				for (var i = 0; i < ranks; i++) {
					// build rank
					var r;
					if (i >= ranks/2) r = ranks-(i+1);
					else r = i;
					var wx = Math.floor(r/2) + 1;
					var wy = Math.ceil(r/2) + 1;
					for (var x = 0; x < wx; x++) {
						var xoff = -wx+1;
						for (var y = 0; y < wy; y++) {
							var yoff = -wy+1;
							var node = new Node(i,xoff+2*x,yoff+2*y);
							node.makeMesh(ranks);
							nodes[ node.key ] = node;
							nodelist.push(node);
						}
					}
					total += wx*wy;
				}
				for (var i = 0; i < nodelist.length; i++) {
					nodelist[i].resolveDownLinks(nodes);
				}
				scene.add(new THREE.Line(linesGeo, linkMat, THREE.LinePieces));
				console.log(total);
				return nodes;
			}

			buildNodes(17);

			var hoverObj = undefined;
			var mouse = new THREE.Vector2();

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( (event.clientY-5) / window.innerHeight ) * 2 + 1;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			window.addEventListener( 'resize', onWindowResize, false );

			var raycaster= new THREE.Raycaster();
			function render() {
				requestAnimationFrame( render );
				var angle=new Date().getTime()/3600.0;
				camera.position.z = Math.cos(angle)*2;
				camera.position.x = Math.sin(angle)*2;
				camera.lookAt(new THREE.Vector3(0,0,0));

				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 ).unproject( camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				var intersects = raycaster.intersectObjects( scene.children );
				if (hoverObj) { hoverObj.material = nodeMat; }
				if ( intersects.length > 0 ) {
					//console.log("HIT");
					hoverObj = intersects[ 0 ].object;
					hoverObj.material=nodeSelMat;
				}

				renderer.render( scene, camera );
			}
			render();
		</script>
	</body>
</html>