<html>
	<head>
		<title>Diamond Go</title>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script type="text/javascript">
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);
			camera.position.z = 3;

			function Node(rank,x,y) {
				this.rank = rank;
				this.x = x;
				this.y = y;
				this.links = [undefined,undefined,undefined,undefined];
			}

			var rankHeight = 0.1;
			var rankDiag = rankHeight * Math.sqrt(2);
			var nodeMat = new THREE.MeshBasicMaterial({color:0x00ff00});
			var nodeSelMat = new THREE.MeshBasicMaterial({color:0x0000ff});
			var nodeGeo = new THREE.BoxGeometry(0.04,0.04,0.04);
			// THREE.ImageUtils.crossOrigin ='file:///home/phooky/Repos/phooky/diamond-go/';
			// console.log(THREE.ImageUtils.crossOrigin);
			// var nodeTex = THREE.ImageUtils.loadTexture( "./node-tex.png" );
   //          var nodeSpriteMat = new THREE.SpriteMaterial( { map: nodeTex, color: 0xffffff, fog: true } );
   //          var sprite = new THREE.Sprite( nodeSpriteMat );
   //          scene.add( sprite );

			function buildNodes(ranks) {
				var nodes = [];
				var total = 0;
				for (var i = 0; i < ranks; i++) {
					// build rank
					var r;
					if (i >= ranks/2) r = ranks-(i+1);
					else r = i;
					var wx = Math.floor(r/2) + 1;
					var wy = Math.ceil(r/2) + 1;
					for (var x = 0; x < wx; x++) {
						var xoff = -wx+1;
						for (var y = 0; y < wy; y++) {
							var yoff = -wy+1;
							var node = new Node(i,xoff+2*x,yoff+2*y);
							nodes.push(node);
							var nodeCube = new THREE.Mesh(nodeGeo,nodeMat);
							nodeCube.position.y = (ranks/2 - node.rank) * rankHeight;
							nodeCube.position.x = node.x * rankDiag;
							nodeCube.position.z = node.y * rankDiag;
							scene.add(nodeCube);
						}
					}
					total += wx*wy;
				}
				console.log(total);
				return nodes;
			}

			buildNodes(17);

			var hoverObj = undefined;
			var mouse = new THREE.Vector2();

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( (event.clientY-5) / window.innerHeight ) * 2 + 1;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			window.addEventListener( 'resize', onWindowResize, false );

			var raycaster= new THREE.Raycaster();
			function render() {
				requestAnimationFrame( render );
				var angle=new Date().getTime()/3600.0;
				camera.position.z = Math.cos(angle)*2;
				camera.position.x = Math.sin(angle)*2;
				camera.lookAt(new THREE.Vector3(0,0,0));

				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 ).unproject( camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				var intersects = raycaster.intersectObjects( scene.children );
				if (hoverObj) { hoverObj.material = nodeMat; }
				if ( intersects.length > 0 ) {
					//console.log("HIT");
					hoverObj = intersects[ 0 ].object;
					hoverObj.material=nodeSelMat;
				}

				renderer.render( scene, camera );
			}
			render();
		</script>
	</body>
</html>